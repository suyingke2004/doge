<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>新闻对话</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <!-- 流星粒子容器 -->
    <div class="stars-container" id="stars-container"></div>
    
    <!-- 鼠标指针粒子容器 -->
    <div class="cursor-particles" id="cursor-particles"></div>
    
    <div class="container">
        <h1>新闻对话</h1>
        
        <!-- 显示聊天历史 -->
        <div class="chat-window" id="chat-window">
            {% for message in chat_history %}
                {% if message.type == 'human' %}
                    <div class="chat-message user-message">
                        <p><strong>你:</strong> {{ message.content }}</p>
                    </div>
                {% elif message.type == 'ai' %}
                    <div class="chat-message ai-message">
                        <p><strong>AI助手:</strong></p>
                        <div>{{ message.content_html | safe }}</div>
                    </div>
                {% endif %}
            {% endfor %}
        </div>

        <!-- 如果没有聊天历史，显示模型选择表单 -->
        {% if not chat_history %}
        <div id="model-selection" class="model-selection">
            <p>选择模型和参数开始对话：</p>
            <form id="model-form" class="model-form">
                <div class="form-group">
                    <label for="model-provider">选择模型提供商</label>
                    <select name="model_provider" id="model-provider">
                        <option value="deepseek" selected>DeepSeek</option>
                        <option value="openai">OpenAI</option>
                        <option value="zhipu">Zhipu AI</option>
                        <option value="ali">Alibaba Cloud</option>
                        <option value="moonshot">Moonshot AI</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="model-name">选择模型</label>
                    <select name="model_name" id="model-name">
                        <!-- 默认模型选项将根据提供商动态生成 -->
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="maxiter">最大迭代次数</label>
                    <input type="number" id="maxiter" name="maxiter" min="1" value="128">
                </div>
                
                <div class="form-group">
                    <label for="topic-input">输入起始主题</label>
                    <input type="text" id="topic-input" name="topic" placeholder="例如：量子计算的最新进展" required>
                </div>
                
                <button type="submit">开始对话</button>
            </form>
        </div>
        
        <!-- 隐藏的聊天表单 -->
        <form id="chat-form" class="chat-form" style="display: none;">
            <input type="text" id="chat-topic-input" name="topic" placeholder="继续提问..." required>
            <input type="hidden" name="model_provider" id="chat-model-provider">
            <input type="hidden" name="model_name" id="chat-model-name">
            <button type="submit">发送</button>
        </form>
        {% else %}
        <!-- 如果有聊天历史，只显示聊天表单 -->
        <form id="chat-form" class="chat-form">
            <input type="text" id="chat-topic-input" name="topic" placeholder="继续提问..." required>
            <input type="hidden" name="model_provider" value="{{ session.get('model_provider', 'deepseek') }}">
            {% if session.get('model_name') %}
            <input type="hidden" name="model_name" value="{{ session.get('model_name') }}">
            {% endif %}
            <button type="submit">发送</button>
        </form>
        {% endif %}

        <a href="{{ url_for('new_chat') }}" class="back-link">开始新对话</a>
    </div>

    <script>
        // 创建流星粒子效果
        document.addEventListener('DOMContentLoaded', function() {
            const starsContainer = document.getElementById('stars-container');
            const starCount = 100; // 流星数量
            
            // 创建流星粒子
            for (let i = 0; i < starCount; i++) {
                createStar();
            }
            
            function createStar() {
                const star = document.createElement('div');
                star.classList.add('star');
                
                // 随机大小 (1-3px)
                const size = Math.random() * 2 + 1;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                
                // 随机位置 (页面顶部和左侧一定范围内)
                const startX = Math.random() * window.innerWidth * 1.5;
                const startY = Math.random() * -window.innerHeight * 0.5;
                star.style.left = `${startX}px`;
                star.style.top = `${startY}px`;
                
                // 随机透明度
                star.style.opacity = Math.random() * 0.8 + 0.2;
                
                // 随机动画持续时间 (2-5秒)
                const duration = Math.random() * 3 + 2;
                star.style.animationDuration = `${duration}s`;
                
                // 随机动画延迟
                const delay = Math.random() * 5;
                star.style.animationDelay = `${delay}s`;
                
                starsContainer.appendChild(star);
                
                // 动画结束后移除元素并创建新的流星
                setTimeout(() => {
                    star.remove();
                    createStar();
                }, duration * 1000);
            }
        });
        document.addEventListener('DOMContentLoaded', function() {
            const modelForm = document.getElementById('model-form');
            const chatForm = document.getElementById('chat-form');
            const topicInput = document.getElementById('topic-input') || document.getElementById('chat-topic-input');
            const chatWindow = document.getElementById('chat-window');
            const modelProviderSelect = document.getElementById('model-provider');
            const modelNameSelect = document.getElementById('model-name');
            const maxiterInput = document.getElementById('maxiter');
            
            // 预设各提供商的模型选项
            const modelOptions = {
                'deepseek': [
                    { value: 'deepseek-chat', text: 'deepseek-chat (默认)' },
                    { value: 'deepseek-coder', text: 'deepseek-coder' }
                ],
                'openai': [
                    { value: 'gpt-4o', text: 'gpt-4o (默认)' },
                    { value: 'gpt-4o-mini', text: 'gpt-4o-mini' },
                    { value: 'gpt-4-turbo', text: 'gpt-4-turbo' }
                ],
                'zhipu': [
                    { value: 'glm-4', text: 'glm-4 (默认)' },
                    { value: 'glm-4-air', text: 'glm-4-air' },
                    { value: 'glm-4-flash', text: 'glm-4-flash' }
                ],
                'ali': [
                    { value: 'qwen-max', text: 'qwen-max (默认)' },
                    { value: 'qwen-plus', text: 'qwen-plus' },
                    { value: 'qwen-turbo', text: 'qwen-turbo' }
                ],
                'moonshot': [
                    { value: 'moonshot-v1-8k', text: 'moonshot-v1-8k (默认)' },
                    { value: 'moonshot-v1-32k', text: 'moonshot-v1-32k' },
                    { value: 'moonshot-v1-128k', text: 'moonshot-v1-128k' }
                ]
            };
            
            // 当提供商改变时，更新模型选项
            if (modelProviderSelect && modelNameSelect) {
                function updateModelOptions() {
                    const provider = modelProviderSelect.value;
                    const models = modelOptions[provider] || [];
                    
                    // 清空现有选项
                    modelNameSelect.innerHTML = '';
                    
                    // 添加新选项
                    models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.value;
                        option.textContent = model.text;
                        modelNameSelect.appendChild(option);
                    });
                }
                
                // 初始化模型选项
                updateModelOptions();
                
                // 添加事件监听器
                modelProviderSelect.addEventListener('change', updateModelOptions);
            }
            
            // 处理模型选择表单提交
            if (modelForm) {
                modelForm.addEventListener('submit', async function(e) {
                    e.preventDefault();
                    
                    const formData = new FormData(modelForm);
                    const topic = formData.get('topic');
                    const modelProvider = formData.get('model_provider');
                    const modelName = formData.get('model_name');
                    
                    if (!topic.trim()) return;
                    
                    // 添加用户消息到聊天窗口
                    const userMessageDiv = document.createElement('div');
                    userMessageDiv.className = 'chat-message user-message';
                    userMessageDiv.innerHTML = `<p><strong>你:</strong> ${topic}</p>`;
                    chatWindow.appendChild(userMessageDiv);
                    
                    // 创建AI消息容器
                    const aiMessageDiv = document.createElement('div');
                    aiMessageDiv.className = 'chat-message ai-message';
                    aiMessageDiv.innerHTML = '<p><strong>AI助手:</strong></p><div id="ai-response"></div><div class="status-indicator" id="status-indicator" style="display: none;"></div>';
                    chatWindow.appendChild(aiMessageDiv);
                    
                    const aiResponseDiv = aiMessageDiv.querySelector('#ai-response');
                    const statusIndicator = aiMessageDiv.querySelector('#status-indicator');
                    
                    // 调试信息
                    console.log('Status indicator element:', statusIndicator);
                    
                    // 滚动到底部
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                    
                    // 隐藏模型选择表单，显示聊天表单
                    document.getElementById('model-selection').style.display = 'none';
                    chatForm.style.display = 'block';
                    
                    // 设置聊天表单的隐藏字段
                    document.getElementById('chat-model-provider').value = modelProvider;
                    if (modelName) {
                        document.getElementById('chat-model-name').value = modelName;
                    }
                    
                    try {
                        // 发送请求到流式端点
                        const response = await fetch('/chat_stream', {
                            method: 'POST',
                            body: formData,
                            headers: {
                                'X-Requested-With': 'XMLHttpRequest'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder('utf-8');
                        let accumulatedText = '';
                        let buffer = ''; // 用于累积不完整的数据
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            const chunk = decoder.decode(value, { stream: true });
                            buffer += chunk; // 累积数据到缓冲区
                            
                            // 按行处理数据
                            const lines = buffer.split('\n');
                            buffer = lines.pop(); // 保留最后一个可能不完整的行在缓冲区中
                            
                            for (const line of lines) {
                                if (line.trim() === '') continue; // 跳过空行
                                
                                // 解析JSON格式的消息
                                try {
                                    const message = JSON.parse(line);
                                    if (message.type === "status") {
                                        // 显示状态消息
                                        statusIndicator.textContent = message.content;
                                        statusIndicator.style.display = "block";
                                    } else if (message.type === "output") {
                                        // 隐藏状态消息
                                        statusIndicator.style.display = "none";
                                        // 更新AI响应
                                        accumulatedText += message.content;
                                        aiResponseDiv.textContent = accumulatedText;
                                    }
                                } catch (e) {
                                    // 如果不是JSON格式，按原来的方式处理
                                    accumulatedText += line;
                                    aiResponseDiv.textContent = accumulatedText;
                                }
                            }
                            
                            // 滚动到底部
                            chatWindow.scrollTop = chatWindow.scrollHeight;
                        }
                        
                        // 在流式响应结束后，更新聊天历史记录
                        // 不需要重新加载页面，保持当前界面状态
                        // 清空输入框
                        topicInput.value = '';
                    } catch (error) {
                        console.error('Error:', error);
                        aiResponseDiv.textContent = '抱歉，发生错误: ' + error.message;
                    }
                });
            }
            
            // 处理聊天表单提交
            if (chatForm) {
                console.log('注册聊天表单提交事件监听器');
                chatForm.addEventListener('submit', async function(e) {
                    console.log('聊天表单提交事件被触发');
                    e.preventDefault();
                    console.log('已阻止默认表单提交行为');
                    
                    // 确保获取到正确的输入框元素
                    const topicInputElement = document.getElementById('chat-topic-input');
                    const topic = topicInputElement ? topicInputElement.value : '';
                    console.log('用户输入:', topic);
                    if (!topic || !topic.trim()) {
                        console.log('输入为空，取消提交');
                        return;
                    }
                    
                    // 添加用户消息到聊天窗口
                    const userMessageDiv = document.createElement('div');
                    userMessageDiv.className = 'chat-message user-message';
                    userMessageDiv.innerHTML = `<p><strong>你:</strong> ${topic}</p>`;
                    chatWindow.appendChild(userMessageDiv);
                    
                    // 清空输入框
                    if (topicInputElement) {
                        topicInputElement.value = '';
                    }
                    
                    // 创建AI消息容器
                    const aiMessageDiv = document.createElement('div');
                    aiMessageDiv.className = 'chat-message ai-message';
                    aiMessageDiv.innerHTML = '<p><strong>AI助手:</strong></p><div id="ai-response"></div><div class="status-indicator" id="status-indicator" style="display: none;"></div>';
                    chatWindow.appendChild(aiMessageDiv);
                    
                    const aiResponseDiv = aiMessageDiv.querySelector('#ai-response');
                    const statusIndicator = aiMessageDiv.querySelector('#status-indicator');
                    
                    // 调试信息
                    console.log('Status indicator element:', statusIndicator);
                    
                    // 滚动到底部
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                    
                    try {
                        console.log('准备发送请求到 /chat_stream');
                        // 发送请求到流式端点
                        const formData = new FormData(chatForm);
                        // 确保topic字段被正确设置
                        formData.set('topic', topic);
                        
                        const response = await fetch('/chat_stream', {
                            method: 'POST',
                            body: formData,
                            headers: {
                                'X-Requested-With': 'XMLHttpRequest'
                            }
                        });
                        
                        console.log('收到响应，状态码:', response.status);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder('utf-8');
                        let accumulatedText = '';
                        let buffer = ''; // 用于累积不完整的数据
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) {
                                console.log('流式响应结束');
                                // 隐藏状态指示器
                                statusIndicator.style.display = "none";
                                break;
                            }
                            
                            const chunk = decoder.decode(value, { stream: true });
                            buffer += chunk; // 累积数据到缓冲区
                            
                            // 按行处理数据
                            const lines = buffer.split('\n');
                            buffer = lines.pop(); // 保留最后一个可能不完整的行在缓冲区中
                            
                            for (const line of lines) {
                                if (line.trim() === '') continue; // 跳过空行
                                
                                // 解析JSON格式的消息
                                    try {
                                        const message = JSON.parse(line);
                                        console.log('Received message:', message); // 调试信息
                                        if (message.type === "status") {
                                            // 显示状态消息
                                            console.log('Setting status text to:', message.content); // 调试信息
                                            statusIndicator.textContent = message.content;
                                            console.log('Setting status display to block'); // 调试信息
                                            statusIndicator.style.display = "block";
                                            console.log('Showing status:', message.content); // 调试信息
                                        } else if (message.type === "output") {
                                            // 隐藏状态消息
                                            console.log('Setting status display to none for output'); // 调试信息
                                            statusIndicator.style.display = "none";
                                            // 更新AI响应
                                            accumulatedText += message.content;
                                            aiResponseDiv.textContent = accumulatedText;
                                            console.log('Output received, hiding status'); // 调试信息
                                        }
                                    } catch (e) {
                                        // 如果不是JSON格式，按原来的方式处理
                                        console.log('Non-JSON message:', line); // 调试信息
                                        accumulatedText += line;
                                        aiResponseDiv.textContent = accumulatedText;
                                    }
                            }
                            
                            // 滚动到底部
                            chatWindow.scrollTop = chatWindow.scrollHeight;
                        }
                        
                        // 在流式响应结束后，更新聊天历史记录
                        // 不需要重新加载页面，保持当前界面状态
                    } catch (error) {
                        console.error('Error:', error);
                        aiResponseDiv.textContent = '抱歉，发生错误: ' + error.message;
                    }
                });
            }
        });
        
        // 创建流星粒子效果 - 彩色增强版
        document.addEventListener('DOMContentLoaded', function() {
            const starsContainer = document.getElementById('stars-container');
            const starCount = 50; // 调整粒子数量
            
            // 创建流星粒子
            for (let i = 0; i < starCount; i++) {
                createStar();
            }
            
            function createStar() {
                // 随机位置 (页面顶部和左侧一定范围内)
                const startX = Math.random() * window.innerWidth * 1.5;
                const startY = Math.random() * -window.innerHeight * 0.5;
                
                // 更长的动画持续时间 (6-10秒)
                const duration = Math.random() * 4 + 6;
                
                // 随机动画延迟
                const delay = Math.random() * 5;
                
                // 创建主粒子
                const star = document.createElement('div');
                star.classList.add('star');
                
                // 粒子尺寸 (6-10px)，模拟真实的流星
                const size = Math.random() * 4 + 6;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                
                star.style.boxShadow = `0 0 ${size/2}px #ffffff, 0 0 ${size}px #ffffff`; // 添加白色发光效果
                
                star.style.left = `${startX}px`;
                star.style.top = `${startY}px`;
                
                // 更高的透明度，使粒子更明显
                star.style.opacity = Math.random() * 0.7 + 0.3;
                
                star.style.animationDuration = `${duration}s`;
                star.style.animationDelay = `${delay}s`;
                
                // 创建连续的拖尾效果
                const trailLength = 15; // 拖尾粒子数量，控制拖尾长度
                for (let i = 1; i <= trailLength; i++) {
                    const trail = document.createElement('div');
                    trail.classList.add('star');
                    
                    // 拖尾粒子逐渐变小
                    const trailSize = size * (1 - i * 0.05);
                    trail.style.width = `${trailSize > 1 ? trailSize : 1}px`;
                    trail.style.height = `${trailSize > 1 ? trailSize : 1}px`;
                    
                    // 拖尾粒子使用白色但透明度递减
                    trail.style.opacity = (0.8 - i * 0.05) * (Math.random() * 0.3 + 0.2);
                    
                    // 设置拖尾粒子的位置和动画
                    trail.style.left = `${startX}px`;
                    trail.style.top = `${startY}px`;
                    trail.style.animationDuration = `${duration}s`;
                    trail.style.animationDelay = `${delay + i * 0.02}s`; // 依次延迟出现
                    
                    starsContainer.appendChild(trail);
                }
                
                starsContainer.appendChild(star);
                
                // 动画结束后移除元素并创建新的流星
                setTimeout(() => {
                    // 移除主粒子和所有拖尾粒子
                    star.remove();
                    // 获取所有拖尾粒子并移除它们
                    const trails = starsContainer.querySelectorAll('.star');
                    for (let i = 0; i < Math.min(trailLength, trails.length); i++) {
                        if (trails[i]) trails[i].remove();
                    }
                    // 重新创建新的流星
                    createStar();
                }, duration * 1000);
            }
        });
        
        // 鼠标指针环绕粒子效果
        document.addEventListener('DOMContentLoaded', function() {
            const cursorParticles = document.getElementById('cursor-particles');
            const particleCount = 12; // 环绕粒子数量
            let mouseX = 0;
            let mouseY = 0;
            let particles = [];
            
            // 创建环绕粒子
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.classList.add('cursor-particle');
                
                // 粒子尺寸 (3-5px)
                const size = Math.random() * 2 + 3;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                // 添加淡蓝色发光效果
                particle.style.backgroundColor = '#87CEEB'; // 淡蓝色
                particle.style.boxShadow = `0 0 ${size/2}px #87CEEB, 0 0 ${size}px #87CEEB`;
                
                // 初始透明度
                particle.style.opacity = Math.random() * 0.5 + 0.3;
                
                cursorParticles.appendChild(particle);
                particles.push({
                    element: particle,
                    angle: (i / particleCount) * Math.PI * 2, // 初始角度
                    distance: Math.random() * 20 + 20, // 距离鼠标指针的距离
                    speed: Math.random() * 0.05 + 0.02, // 旋转速度
                    size: size
                });
            }
            
            // 监听鼠标移动
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            // 粒子动画循环
            function animateParticles() {
                particles.forEach(particle => {
                    // 更新角度
                    particle.angle += particle.speed;
                    
                    // 计算新位置
                    const x = mouseX + Math.cos(particle.angle) * particle.distance;
                    const y = mouseY + Math.sin(particle.angle) * particle.distance;
                    
                    // 应用新位置
                    particle.element.style.left = `${x}px`;
                    particle.element.style.top = `${y}px`;
                    
                    // 随机改变透明度产生闪烁效果
                    particle.element.style.opacity = Math.random() * 0.5 + 0.3;
                });
                
                requestAnimationFrame(animateParticles);
            }
            
            // 启动动画
            animateParticles();
        });
    </script>
</body>
</html>